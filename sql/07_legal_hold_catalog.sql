-- ============================================================
-- Phase 5: Legal Hold & Backup Lookup Catalog
--
-- Goal:
--   Maintain lightweight metadata to answer:
--     "Which backups contain data for user X?"
--   and enforce:
--     "Do not delete keys while a legal hold is active."
--
-- Notes:
--   This is metadata only. No backup rewriting is required.
-- ============================================================

-- 1) Legal holds: active holds block cryptographic deletion
DROP TABLE IF EXISTS legal_holds CASCADE;

CREATE TABLE legal_holds (
  hold_id      BIGSERIAL PRIMARY KEY,
  user_id      BIGINT NOT NULL,
  hold_reason  TEXT NOT NULL,           -- e.g., case number, investigation, audit
  created_at   TIMESTAMPTZ NOT NULL DEFAULT now(),
  released_at  TIMESTAMPTZ              -- NULL means hold is active
);

CREATE INDEX idx_legal_holds_user_active
ON legal_holds(user_id)
WHERE released_at IS NULL;


-- 2) Backup runs: represent backup snapshots or backup windows
DROP TABLE IF EXISTS backup_runs CASCADE;

CREATE TABLE backup_runs (
  backup_id    BIGSERIAL PRIMARY KEY,
  backup_type  TEXT NOT NULL CHECK (backup_type IN ('FULL', 'INCR')),
  started_at   TIMESTAMPTZ NOT NULL,
  ended_at     TIMESTAMPTZ NOT NULL,
  created_at   TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_backup_runs_time ON backup_runs(started_at, ended_at);


-- 3) Backup -> User lightweight index
--    This is the key lookup structure: "user X appears in backups {..}"
DROP TABLE IF EXISTS backup_user_index CASCADE;

CREATE TABLE backup_user_index (
  backup_id   BIGINT NOT NULL REFERENCES backup_runs(backup_id) ON DELETE CASCADE,
  user_id     BIGINT NOT NULL,
  first_seen  TIMESTAMPTZ NOT NULL DEFAULT now(),
  last_seen   TIMESTAMPTZ NOT NULL DEFAULT now(),
  PRIMARY KEY (backup_id, user_id)
);

CREATE INDEX idx_backup_user_index_user ON backup_user_index(user_id);


-- 4) Helper function: check if a user is under active legal hold
CREATE OR REPLACE FUNCTION is_user_on_legal_hold(p_user_id BIGINT)
RETURNS BOOLEAN
LANGUAGE sql
AS $$
  SELECT EXISTS (
    SELECT 1
    FROM legal_holds
    WHERE user_id = p_user_id
      AND released_at IS NULL
  );
$$;


-- 5) Function: record that a given backup contains certain users
--    (In production this would be generated by a backup job scanning metadata.)
CREATE OR REPLACE FUNCTION record_backup_user(
  p_backup_id BIGINT,
  p_user_id BIGINT
) RETURNS VOID
LANGUAGE plpgsql
AS $$
BEGIN
  INSERT INTO backup_user_index(backup_id, user_id, first_seen, last_seen)
  VALUES (p_backup_id, p_user_id, now(), now())
  ON CONFLICT (backup_id, user_id)
  DO UPDATE SET last_seen = now();
END;
$$;
